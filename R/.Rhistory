'a' %in% x
x = "ab"
"a" %in% x
setdiff(x,"a")
setdiff(names(d1), "sd")
grepl(names(d1), "sd")
grepl(names(d1), "sd", fixed = T)
grepl(names(d1)[103], "sd", fixed = T)
grepl("sd1", "sd", fixed = T)
grepl("sd", names(d1)[103], fixed = T)
mnames
arglist_eval
length(setdiff(names(arglist_eval)),"x")
names(arglist_eval)
setduff(names(arglist_eval), "x")
setdiff(names(arglist_eval), "x")
length(setdiff(names(arglist_eval), "x"))
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::build()
devtools::document()
devtools::check()
devtools::check()
devtools::test()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::test()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::test()
library(devtools)
devtools:check()
devtools::check()
normal <- function(mean,sd){-log(2*pi)-log(sd)-(x-mean)^2/(2*sd^2)}
m <- function(b0) { b0*dd$latitude^2 }
m(b0=3)
set.seed(101)
dd <- data.frame(y = rpois(100, lambda = 2),
latitude = rnorm(100))
## manual function
## pois needs x in its environment
x <- dd$y
pois <- function(lambda){x*log(lambda)-lambda-lfactorial(x)}
normal <- function(mean,sd){-log(2*pi)-log(sd)-(x-mean)^2/(2*sd^2)}
## MUST use this (rather than dpois) for now:
## FIXME: can we get numDeriv() to work with a multi-parameter model?
m(b0=3)
test_mean <- m(b0=3)
normal(test_mean, sd=1)
temp_norm<- normal(test_mean, sd=1)
temp_nomr
temp_norm
form3 <- y ~ dnorm(mean = b0 * latitude^2, sd = 1)
temp_ff <- mkfun(form3, data=dd)
dnorm(dd$y, test_mean, sd=1, log=TRUE)
dnorm(dd$y, test_mean, sd=1)
dnorm(dd$y, test_mean, sd=1, log=TRUE)
temp_norm
normal(1,1)
dnorm(x, 1,1, log=# Tue Nov 17 19:49:19 2020 ------------------------------
)
dnorm(x, 1,1, log=T)
form4 <- y ~ dnorm(mean = b0 + b1 * latitude^2, sd = 1)
ff4 <- mkfun(form4, data=dd)
ff4$fn(c(b0=1, b1=2)) == -sum(dnorm(dd$y, mean=1 + 2*dd$latitude^2, sd=1, log=TRUE))
dnorm(x, mean=1, sd=2)
dnorm(x, mean=1, sd=2,log = T)
## manual function
## pois needs x in its environment
x <- dd$y
normal(1,1)
normal(1,2)
dnorm(x, 1, 2, log=T)
x <- 1
normal(0,1)
dnorm(x, 0,1)
dnorm(x, 0,1, log=T)
check()
test()
test()
test()
test()
ff <- mkfun(form, data=dd)
set.seed(101)
dd <- data.frame(y = rpois(100, lambda = 2),
latitude = rnorm(100))
## manual function
## pois needs x in its environment
x <- dd$y
pois <- function(lambda){x*log(lambda)-lambda-lfactorial(x)}
normal <- function(mean,sd){-log(2*pi)-log(sd)-(x-mean)^2/(2*sd^2)}
## MUST use this (rather than dpois) for now:
## FIXME: can we get numDeriv() to work with a multi-parameter model?
#formula and data
form <- y ~ dpois(lambda = b0 * latitude^2)
ff <- mkfun(form, data=dd)
expect_equal(names(ff), c("fn","gr"))
expect_equal(ff$fn(c(b0=3)),
-sum(pois(lambda(b0=3))))
x <- dd$y  ## pois looks for x in its environment
lambda <- function(b0) { b0*dd$latitude^2 }
expect_equal(ff$fn(c(b0=3)),
-sum(pois(lambda(b0=3))))
b0 <- 3
lambda <- b0*dd$latitude^2
ff$gr(c(b0=3))
test()
pois <- function(lambda){x*log(lambda)-lambda-lfactorial(x)}
## manual function
## pois needs x in its environment
x <- dd$y
dpois(x, lambda=1,log=T)
pois(1)
dnorm(x, 1,1,)
dnorm(x, 1,1, log=T)
normal(1,1,)
normal(1,1)
log(normal(1,1))
temp <- normal(1,1)
log(temp)
y <- 1
normal(y,1,1)
x <- 1
normal(y)
normal(1,1)
dnorm(x,1,1)
dnorm(x,1,1, log=T)
normal <- function(mean,sd){-log((2*pi)^0.5))-log(sd)-(x-mean)^2/(2*sd^2)}
normal <- function(mean,sd){-log((2*pi)^0.5)-log(sd)-(x-mean)^2/(2*sd^2)}
normal(1,1)
test()
test()
test()
test()
test()
M <- m(b0=1, b1=2)
m <- function(b0, b1) {b0 + b1*dd$latitude^2}
M <- m(b0=1, b1=2)
M
test()
fullgrad <- rep(NA, length(M))
fullgrad
numDeriv::grad(normal)
numDeriv::grad(normal,mean)
numDeriv::grad(normal,mean,sd)
numDeriv::grad(normal,1,1)
numDeriv::grad(pois,1)
numDeriv::grad(normal,1)
numDeriv::grad(normal,1,2)
numDeriv::grad(normal,mean=1, sd=1)
x <- 1
numDeriv::grad(normal,mean=1, sd=1)
numDeriv::grad(normal,mean=1)
numDeriv::grad(normal,c(1,2))
test()
fr <- function(x) {   ## Rosenbrock Banana function
x1 <- x[1]
x2 <- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
grr <- function(x) { ## Gradient of 'fr'
x1 <- x[1]
x2 <- x[2]
c(-400 * x1 * (x2 - x1 * x1) - 2 * (1 - x1),
200 *      (x2 - x1 * x1))
}
xx <-  optim(c(-1.2,1), fr)
xx
fr(1,1)
fr(1)
fr
grr
fr(1)
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
return(opt)
}
mle
l
mle
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
d <- data.frame(x=0:10,y=c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8))
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0
d <- data.frame(x=0:10,y=c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8))
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
return(opt)
}
mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
bbmle::mle2(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
xx
fit0
fi0[[1:2]]
fi0[[2]]
fit0[[2]]
fit0[[1:2]]
fit0$par
fit0$(1:2)
fit0[[1:2]]
fit0[[1]]
fit0[[2]]
fit0[1]
fit0[1:2]
fit0$coefficient <- fit0$par
git0
fit0
fit0$Coefficients <- fit0$par
fit0$`Negative Log-Likelihood` <- fit0$value
fit0
fit0$Negative Log-Likelihood <- fit0$value
fit0$(Negative Log-Likelihood) <- fit0$value
fit0$'Negative Log-Likelihood' <- fit0$value
git0
fit0
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0$'Negative Log-Likelihood' <- fit0$value
git0
fit0
fit0$Negative-Log-Likelihood <- fit0$value
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0$Coefficients <- opt$par
fit0$Coefficients <- fit0$par
fit0$`Negative Log-likelihood` <- fit0$value
fit0[-2:-1]
names(fit0)
fit0[-2]
fit0[-1]
tail(fit0, 2)
bbmle::mle2(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit1 <- bbmle::mle2(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Coefficients <- opt$par
opt$`Negative Log-likelihood` <- opt$value
output <- tail(opt, 2)
return(output)
}
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0
fit1
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- form
opt$Coefficients <- opt$par
opt$`Negative Log-likelihood` <- opt$value
output <- tail(opt, 3)
return(output)
}
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
git0
fit0
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y)),data=d)
fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y)),data=d)
fit4
fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y)),data=d, optCtrl="Nelder-Mead")
fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y)),data=d, optCtrl="BFGS")
optCtrl=list(method="BFGS")
optCtrl
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y)),data=d, optCtrl=list(method="Nelder-Mead"))
fit3
fit4
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y)),data=d, optCtrl=list(method="BFGS"))
fit0
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- form
opt$Coefficients <- opt$par
opt$Log-likelihood <- opt$value
output <- tail(opt, 3)
return(output)
}
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
form4 <- y ~ dnorm(mean = b0 + b1 * latitude^2, sd = 1)
form4
set.seed(101)
dd <- data.frame(y = rpois(100, lambda = 2),
latitude = rnorm(100))
## manual function
## pois needs x in its environment
x <- dd$y
ff4 <- mkfun(form4, data=dd)
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=1),data=d)
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- form
opt$Coefficients <- opt$par
opt$'Log-likelihood' <- opt$value
output <- tail(opt, 3)
return(output)
}
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- form
opt$Coefficients <- opt$par
opt$`Log-likelihood` <- opt$value
output <- tail(opt, 3)
return(output)
}
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=1),data=d)
fit3
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
fit3
fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y),ysd=2),data=d)
fit4
fit0
output <- list(Log-likelihood=fit0$`Negative Log-likelihood`)
output <- list(`Log-likelihood`=fit0$`Negative Log-likelihood`)
output
output <- list(as.character(Log-likelihood)=fit0$`Negative Log-likelihood`)
as.character(Log-Likelihood)
as.character(``)
as.character(`Log-Likelihood`)
expression(Log-Likelihood)
sprintf(Log-Likelihood)
toString(Log-Likelihood)
expression(mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d))
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- paste(form, start, data)
opt$Coefficients <- opt$par
opt$`Log-likelihood` <- opt$value
output <- tail(opt, 3)
return(output)
}
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
fit3
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- expression(form, start, data)
opt$Coefficients <- opt$par
opt$`Log-likelihood` <- opt$value
output <- tail(opt, 3)
return(output)
}
variable.names(mle)
variable.names(mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d))
paste(mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d))
sapply(mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d), as.character)
sapply(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d, as.character)
}
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- paste(sapply(c(form, start, data), as.character, collapse=" ")
opt$Coefficients <- opt$par
opt$`Log-likelihood` <- opt$value
output <- tail(opt, 3)
return(output)
}
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- paste(sapply(c(form, start, data), as.character), collapse=" ")
opt$Coefficients <- opt$par
opt$`Log-likelihood` <- opt$value
output <- tail(opt, 3)
return(output)
}
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- c(form, start, data)
opt$Coefficients <- opt$par
opt$`Log-likelihood` <- opt$value
output <- tail(opt, 3)
return(output)
}
fit0
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0
methods(mkfun)
methods(mean)
methods(mle)
methods("mle")
methods(qzmle::mle)
show(mean)
methods(mean)
class(fit1)
class(fit0)
getS3method(mean,"default")
getS3method('mean',"default")
apropos(mean)
apropos("mean")
apropos("bbmle::mle2")
getS3method("bbmle::mle2")
getS3method("mle2")
show("mle2")
show(mle2)
show(bbmle::mle2())
show(bbmle::mle2
)
methods(bbmle::mle2)
methods(class = "lm")
ftype(bbmle::mle2())
install.packages("sloop")
sloop::ftype(bbmle::mle2())
sloop::ftype(mle2())
sloop::ftype(mle2
)
library(bbmle)
sloop::ftype(mle2)
bbmle:mle2
bbmle::mle2
s3_methods_class("mean")
s3_methods_generic("mean")
sloop::s3_methods_generic("mean")
sloop::s3_methods_class("mean")
sloop::s3_methods_class("ordered")
fit1
names(fit1)
summary(fit1)
summary(fit0)
print(fit1)
print(fit0)
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
opt$Call <- form
opt$Coefficients <- opt$par
opt$`Log-likelihood` <- opt$value
output <- tail(opt, 3)
return(output)
}
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
print(fit0)
summary(fit0)
vcov(fit1)
git1
fit1
coef(fit1)
logLik(fit1)
class(fit1)
class(fit0)
#'fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y),ysd=2),data=d)
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList<- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(optim, c(argList,optCtrl))
## trying to make it looks like bbmle output
opt$Call <- form ## need to fix to print out all input arg
opt$Coefficients <- opt$par
opt$`Log-likelihood` <- opt$value
output <- tail(opt, 3)
structure(output, class="mle")
return(output)
}
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
class(fit0)
fit0
class(fit0)
class(fit1)
print(fit0)
d <- data.frame(x=0:10,y=c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8))
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit1 <- bbmle::mle2(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0
fit1
fit0
x <- 1
x
print(c(1,2,3))
list(c(1,2,3))
names(list)
list(x = c(1,2,3))
list[[1]]
list[[x]]
a <- list(x = c(1,2,3))
a[[x]]
a[[1]]
a$x
