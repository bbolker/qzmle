colnames(tvcov) <- names(opt$par)
rownames(tvcov) <- names(opt$par)
result <- list()
result$call <- match.call()
result$coefficients <- opt$par
result$minuslogl <- opt$value
result$tvcov <- tvcov
class(result) <- "qzmle"
return(result)
}
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit0
fit0$tvcov
vcov.qzmle <- function(x, ...) {
return(tvcov)
}
vcov(fit0)
vcov.qzmle <- function(x, ...) {
return(x$tvcov)
}
vcov(fit0)
logLik.qzmle <- function(x, ...) {
cat(-1*round(x$minuslogl, 2))
}
#'@export
vcov.qzmle <- function(x, ...) {
cat(x$tvcov)
}
vcov(fit0)
#'@export
logLik.qzmle <- function(x, ...) {
cat(-1*round(x$minuslogl, 2))
}
#'@export
vcov.qzmle <- function(x, ...) {
return(x$tvcov)
}
vcov(fit0)
logLik.qzmle(fit0)
logLik(fit4)
logLik.qzmle <- function(x, ...) {
cat("'log Lik.' ", -1*round(x$minuslogl, 2))
cat(" (df=", length(x$coefficients), ")")
}
logLik.qzmle(fit0)
logLik.qzmle <- function(x, ...) {
cat("'log Lik.' ", -1*round(x$minuslogl, 2))
cat(" (df=",length(x$coefficients),")")
}
logLik.qzmle(fit0)
fit0
fit4
summary(fit4)
logLik.qzmle <- function(x, ...) {
cat("'log Lik.' ", -1*round(x$minuslogl, 2))
cat(" (df=")
cat(length(x$coefficients))
cat(")")
}
fit0
logLik.qzmle(fit0)
vcov.qzmle(fit3)
vcov.qzmle(fit4)
fit3
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList <- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(stats::optim, c(argList,optCtrl))
## vcov is the inverse of hessian (jacobian of gradient)
tvcov <- MASS::ginv(numDeriv::jacobian(gr, opt$par))
colnames(tvcov) <- names(opt$par)
rownames(tvcov) <- names(opt$par)
result <- list()
result$call <- match.call()
result$coefficients <- opt$par
result$minuslogl <- opt$value
result$tvcov <- tvcov
class(result) <- "qzmle"
return(result)
}
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList <- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(stats::optim, c(argList,optCtrl))
## vcov is the inverse of hessian (jacobian of gradient)
tvcov <- MASS::ginv(numDeriv::jacobian(ff$gr, opt$par))
colnames(tvcov) <- names(opt$par)
rownames(tvcov) <- names(opt$par)
result <- list()
result$call <- match.call()
result$coefficients <- opt$par
result$minuslogl <- opt$value
result$tvcov <- tvcov
class(result) <- "qzmle"
return(result)
}
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
vcov.qzmle(fit3)
a <- vcov.qzmle(fit3)
a
sqrt(diag(a))
summary(fit4)
fit3
0/0
4.7602e-18/4.7602e-18
4.7602e-18/2
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cblind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval)
print(coefmat)
}
summary.qzmle(fit0)
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval)
print(coefmat)
}
summary.qzmle(fit0)
a
b <- sqrt(diag(a))
b
fit3$coefficients
test <- cbind(Estimate=fit3$coefficients,
`Std. Error`=b)
test
class(test)
zval <- test[, 1]/test[, 2]
zval
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList <- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(stats::optim, c(argList,optCtrl))
## vcov is the inverse of hessian (jacobian of gradient)
hess <- numDeriv::jacobian(ff$gr, opt$par)
tvcov <- MASS::ginv(hess)
colnames(tvcov) <- names(opt$par)
rownames(tvcov) <- names(opt$par)
result <- list()
result$call <- match.call()
result$coefficients <- opt$par
result$minuslogl <- opt$value
result$tvcov <- tvcov
class(result) <- "qzmle"
return(result)
}
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
git0
fit0
vcov.qzmle(fit0)
vcov.qzmle(fit3)
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList <- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(stats::optim, c(argList,optCtrl))
## vcov is the inverse of hessian (jacobian of gradient)
hess <- numDeriv::jacobian(ff$gr, opt$par)
tvcov <- solve(hess)
colnames(tvcov) <- names(opt$par)
rownames(tvcov) <- names(opt$par)
result <- list()
result$call <- match.call()
result$coefficients <- opt$par
result$minuslogl <- opt$value
result$tvcov <- tvcov
class(result) <- "qzmle"
return(result)
}
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList <- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(stats::optim, c(argList,optCtrl))
## vcov is the inverse of hessian (jacobian of gradient)
hess <- numDeriv::jacobian(ff$gr, opt$par)
tvcov <- MASS::ginv(hess)
colnames(tvcov) <- names(opt$par)
rownames(tvcov) <- names(opt$par)
result <- list()
result$call <- match.call()
result$coefficients <- opt$par
result$minuslogl <- opt$value
result$tvcov <- tvcov
class(result) <- "qzmle"
return(result)
}
summary.qzmle(fit0)
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
zval <- cmat[,1]]/cmat[, 2]
pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval)
print(coefmat)
}
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
zval <- cmat[,1]]/cmat[, 2]
pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval)
print(coefmat)
}
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
zval <- cmat[,1]/cmat[, 2]
pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval)
print(coefmat)
}
summary.qzmle(fit0)
vcov.qzmle(fit0)
fit0$coefficients
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
##pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval
##,"Pr(z)"=pval
)
print(coefmat)
}
summary.qzmle(fit0)
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
##pval <- 2*pnorm(-abs(zval))
##coefmat <- cbind(cmat,"z value"=zval
##,"Pr(z)"=pval
)
print(cmat)
}
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
##pval <- 2*pnorm(-abs(zval))
##coefmat <- cbind(cmat,"z value"=zval
##,"Pr(z)"=pval
##)
print(cmat)
}
summary.qzmle(fit0)
b
test
test[, 1]/test[,2]
fit1
summary(fit1)
test
summary(fit4)
options(scipen = 20)
#' @importFrom stats optim
#' @importFrom numDeriv jacobian
#' @importFrom MASS ginv
mle <- function(form, start, data, optCtrl=list(method="BFGS")) {
ff <- mkfun(form, data)
argList <- list(par=unlist(start), fn=ff$fn, gr=ff$gr)
opt <- do.call(stats::optim, c(argList,optCtrl))
## vcov is the inverse of hessian (jacobian of gradient)
hess <- numDeriv::jacobian(ff$gr, opt$par)
tvcov <- MASS::ginv(hess) ## solve() gives error for non-invertible matrix
colnames(tvcov) <- names(opt$par)
rownames(tvcov) <- names(opt$par)
result <- list()
result$call <- match.call()
result$coefficients <- opt$par
result$minuslogl <- opt$value
result$tvcov <- tvcov
class(result) <- "qzmle"
return(result)
}
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
fit3
vcov.qzmle(fit3)
matrix(numeric(0),0,0)
c <- matrix(numeric(0),0,0)
c
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tcov)))
#zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
##pval <- 2*pnorm(-abs(zval))
##coefmat <- cbind(cmat,"z value"=zval
##,"Pr(z)"=pval
##)
print(cmat)
}
vcov.qzmle(fit3)
summary.qzmle(fit0)
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tvcov)))
#zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
##pval <- 2*pnorm(-abs(zval))
##coefmat <- cbind(cmat,"z value"=zval
##,"Pr(z)"=pval
##)
print(cmat)
}
summary.qzmle(fit0)
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tvcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval
)
print(coefmat)
}
summary.qzmle(fit0)
summary(fit1)
m1 <- lm(y~x, data=d)
coef(m1) ## uses stats:::coef.default
print(s <- summary(m1))
coef(s)
## what to use to print a coefficient table prettily
printCoefmat(coef(s))
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tvcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval)
printCoefmat(coef(x))
}
summary.qzmle(fit0)
coef(fit0)
#' @export
summary.qzmle <- function(x, ...) {
cat("Maximum likelihood estimation\n\nCall:\n")
print(x$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=x$coefficients,
`Std. Error`=sqrt(diag(x$tvcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
pval <- 2*pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval)
printCoefmat(coefmat)
}
summary.qzmle(fit0)
summary.qzmle(fit3)
devtools
devtools::check()
devtools::document()
rm(list = c("logLik.qzmle", "mle", "print.qzmle", "summary.qzmle", "vcov.qzmle"))
devtools::document()
devtools::check()
?pnomr
?pnorm
?printCoefmat
devtools::document()
devtools::check()
devtools::document()
devtools::document()
vcov(fit0)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
roxygen2::roxygenise()
rm(list=ls())
devtools::check()
update.packages("roxygen2")
devtools::check()
install.packages("roxygen2")
install.packages("roxygen2")
devtools::check()
devtools::check()
devtools::load_all()
d <- data.frame(x=0:10,y=c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8))
fit0 <- mle(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
summary.qzmle(fit0)
fit1 <- bbmle::mle2(y~dpois(lambda=ymean),start=list(ymean=mean(d$y)),data=d)
fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y),ysd=2),data=d)
library(bbmle)
summary(fit1)
#' @export
#' @importFrom stats pnorm printCoefmat
summary.qzmle <- function(object, ...) {
check_dots(...)
cat("Maximum likelihood estimation\n\nCall:\n")
print(object$call)
cat("\nCoefficients:\n")
cmat <- cbind(Estimate=object$coefficients,
`Std. Error`=sqrt(diag(object$tvcov)))
zval <- cmat[, "Estimate"]/cmat[, "Std. Error"]
pval <- 2*stats::pnorm(-abs(zval))
coefmat <- cbind(cmat,"z value"=zval,"Pr(z)"=pval)
stats::printCoefmat(coefmat)
cat("\n-2 log L:", -2*object$minuslogl)
}
summary.qzmle(fit0)
fit1
summary(fit3)
summary(fit4)
summary(fit0)
devtools::check()
devtools::check()
devtools::check()
devtools::document()
rm(list=ls())
devtools::document()
devtools::check()
install.packages("devtools")
install.packages("devtools")
devtools::document()
devtools::check()
d <- data.frame(x=0:10,y=c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8))
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
library(bbmle)
## twoWords, two.words, two_words, twowords, TwoWords
check_dots <- function(...) {
if (length(list(...))>0) {
stop("unused parameters passed to method")
}
}
## twoWords, two.words, two_words, twowords, TwoWords
check_dots <- function(...) {
if (length(list(...))>0) {
stop("unused parameters passed to method")
}
}
summary(fit4)
fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y),ysd=2),data=d)
summary(fit4)
summary.qzmle(fit3)
ls()
devtools::load_all()
rm(list=ls())
devtools::load_all()
library(bbmle)
fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y),ysd=2),data=d)
d <- data.frame(x=0:10,y=c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8))
fit4 <- bbmle::mle2(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y),ysd=2),data=d)
stdEr(fit4)
vcov(fit4)
#' @export
stdEr.qzmle <- function(object, ...){
check_dots(...)
print(sqrt(diag(object$tvcov)))
}
fit3 <- mle(y~dnorm(mean=ymean, sd=2),start=list(ymean=mean(d$y), ysd=2),data=d)
stdEr.qzmle(fit3)
devtools::check()
rm(list = ls())
devtools::check()
