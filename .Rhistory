user_r("tmb")
library(devtools)
user_r("tmb")
use_r("tmb")
load_all()
exists("tmb", where = globalenv(), inherits = FALSE)
check()
library(Deriv)
Simplify("x+x")
Simplify("x+y")
Simplify("x*3")
Simplify("x*3")
Simplify("x*3+3*4")
pi
3^2
e^2
exp^2
exp
exp(2)
Deriv(exp(x))
Deriv(2x)
Deriv(2x)
Deriv(2*x)
Deriv(2*x, x)
Deriv("2*x")
Deriv("exp(x)")
Deriv(pi*x)
Deriv("pi*x")
Deriv("y*x")
Deriv("y*x",y)
Deriv("y*x",'y')
library(devtools)
use_r("tmb")
load_all()
form <- y ~ dpois(lambda = b1 * latitude^2)
set.seed(101)
dd <- data.frame(
y = rpois(100, lambda = 2),
latitude = rnorm(100)
)
## debug(mkfun)
ff <- mkfun(form, data=dd)
## debug(ff)
ff$fn(c(b0=1)) ##417.6891
# for testing
form <- y ~ dpois(lambda = b0 * latitude^2)
set.seed(101)
dd <- data.frame(
y = rpois(100, lambda = 2),
latitude = rnorm(100)
)
## debug(mkfun)
ff <- mkfun(form, data=dd)
## debug(ff)
ff$fn(c(b0=1))
ff$gr(c(b0=1)) ## -113.5597
library(testthat)
test_check(mkfun)
library(qzmle)
test_check(mkfun)
Sys.setenv("R_TESTS" = "")
test_check(mkfun)
library(Deriv)
# List of log-lik function for different ditributions
loglik_list <- list(
dpois = list(expr=expression(x * log(lambda) - lambda - lfactorial(x)),
params=c("lambda")),
dnorm = list(expression(-log(2*pi*sd) - (x-mean)^2/(2*sd^2)),
params=c("mean","sd"))
)
#### need to convert pi as a build-in constant??? what if pi is a parameter
### take care of maybe the e constant
## form -> objective function (i.e. a function that computes -sum(dpois(y, lambda=b0*latitude^2))
##  where the variables in the formula are *evaluated* in an environment that
##  includes the current parameter
##  values and information stored in a 'data' variable
## data frame lat, long
y ~ dpois(exp(log_lambda), ...,
parameters = list(log_lambda = ~ poly(lat, long, 2))
)
mkfun <- function(formula, data) {
RHS <- formula[[3]] # dpois(lambda = (b0 * latitude^2))
response <- formula[[2]] #y
ddistn <- as.character(RHS[[1]]) ## dpois /// get the name of distribution variable
arglist <- as.list(RHS[-1]) ## $lambda = (b0 * latitude^2) ///delete function name
arglist1 <- c(
list(x = response),
arglist, ##
list(log = TRUE)
)
fn <- function(pars) { ## parameter
pars_and_data <- c(as.list(pars), data)
r <- with(
pars_and_data,
-sum(do.call(ddistn, arglist1))
)
return(r)
}
gr <- function(pars) {
pars_and_data <- c(as.list(pars), data)
if (!ddistn %in% names(loglik_list)) {
stop("I can't evaluate the derivative for ", sQuote(ddistn))
}
## eventually we need to calculate partial derivatives of the log-likelihood
## with respect to all of its parameters
LL <- loglik_list[[ddistn]]$expr
mnames <- loglik_list[[ddistn]]$params
## ???
## setdiff(all.vars(LL), "x")  ## response var should be the only non-parameter
d0 <- Deriv(LL, mnames)
## evaluate all of the arguments to the log-likelihood
arglist_eval <- lapply(arglist, eval, pars_and_data) ##lambda
## evaluate response variable and assign its value to 'x'
arglist_eval$x <- eval(response, pars_and_data) #x = y
## derivative of log-lik wrt PDF parameters
d1 <- eval(d0, arglist_eval) ## sub back to d0
## compute the deriv of log_lik with respect to its parameters
parnames <- setdiff(all.vars(RHS), names(data))
dlist <- list()
glist <- list()
for (p in parnames) {
dlist[[p]] <- eval(Deriv(arglist$lambda, p), pars_and_data)
glist[[p]] <- -sum(d1 * dlist[[p]])
}
return(unlist(glist))
## d(loglik_pois/d(lambda))* d(lambda)/d(b0)
}
return(list(fn = fn, gr = gr))
}
## PDF param <- multiple model parameters
form2 <- y ~ dpois(lambda = b0 + b1 * latitude^2)
## ff <- mkfun(form2)
## what happens if we forget data? error ...
ff2 <- mkfun(form2, data=dd)
ff2$fn(c(b0=1,b1=2))
ff2$gr(c(b0=1,b1=2))
## testing
ff$gr(c(b1=2)) == ff2$gr(c(b0=0, b1=2))[["b1"]]
## ff <- mkfun(form2)
## what happens if we forget data? error ...
ff2 <- mkfun(form2, data=dd)
## testing
ff$gr(c(b1=2)) == ff2$gr(c(b0=0, b1=2))[["b1"]]
ff2$gr(c(b0=0, b1=2))[["b1"]]
ff$gr(c(b1=2))
## testing
ff$gr(c(b0=2)) == ff2$gr(c(b0=0, b1=2))[["b1"]]
ff$gr(c(b0=2))
mkfun <- function(formula, data) {
if(missing(data)) {
stop(paste("a is required"))
}
RHS <- formula[[3]] # dpois(lambda = (b0 * latitude^2))
response <- formula[[2]] #y
ddistn <- as.character(RHS[[1]]) ## dpois /// get the name of distribution variable
arglist <- as.list(RHS[-1]) ## $lambda = (b0 * latitude^2) ///delete function name
arglist1 <- c(
list(x = response),
arglist, ##
list(log = TRUE)
)
fn <- function(pars) { ## parameter
pars_and_data <- c(as.list(pars), data)
r <- with(
pars_and_data,
-sum(do.call(ddistn, arglist1))
)
return(r)
}
gr <- function(pars) {
pars_and_data <- c(as.list(pars), data)
if (!ddistn %in% names(loglik_list)) {
stop("I can't evaluate the derivative for ", sQuote(ddistn))
}
## eventually we need to calculate partial derivatives of the log-likelihood
## with respect to all of its parameters
LL <- loglik_list[[ddistn]]$expr
mnames <- loglik_list[[ddistn]]$params
## ???
## setdiff(all.vars(LL), "x")  ## response var should be the only non-parameter
d0 <- Deriv(LL, mnames)
## evaluate all of the arguments to the log-likelihood
arglist_eval <- lapply(arglist, eval, pars_and_data) ##lambda
## evaluate response variable and assign its value to 'x'
arglist_eval$x <- eval(response, pars_and_data) #x = y
## derivative of log-lik wrt PDF parameters
d1 <- eval(d0, arglist_eval) ## sub back to d0
## compute the deriv of log_lik with respect to its parameters
parnames <- setdiff(all.vars(RHS), names(data))
dlist <- list()
glist <- list()
for (p in parnames) {
dlist[[p]] <- eval(Deriv(arglist$lambda, p), pars_and_data)
glist[[p]] <- -sum(d1 * dlist[[p]])
}
return(unlist(glist))
## d(loglik_pois/d(lambda))* d(lambda)/d(b0)
}
return(list(fn = fn, gr = gr))
}
mkfun(form2)
mkfun <- function(formula, data) {
if(missing(data)) {
stop(paste("missing data..."))
}
RHS <- formula[[3]] # dpois(lambda = (b0 * latitude^2))
response <- formula[[2]] #y
ddistn <- as.character(RHS[[1]]) ## dpois /// get the name of distribution variable
arglist <- as.list(RHS[-1]) ## $lambda = (b0 * latitude^2) ///delete function name
arglist1 <- c(
list(x = response),
arglist, ##
list(log = TRUE)
)
fn <- function(pars) { ## parameter
pars_and_data <- c(as.list(pars), data)
r <- with(
pars_and_data,
-sum(do.call(ddistn, arglist1))
)
return(r)
}
gr <- function(pars) {
pars_and_data <- c(as.list(pars), data)
if (!ddistn %in% names(loglik_list)) {
stop("I can't evaluate the derivative for ", sQuote(ddistn))
}
## eventually we need to calculate partial derivatives of the log-likelihood
## with respect to all of its parameters
LL <- loglik_list[[ddistn]]$expr
mnames <- loglik_list[[ddistn]]$params
## ???
## setdiff(all.vars(LL), "x")  ## response var should be the only non-parameter
d0 <- Deriv(LL, mnames)
## evaluate all of the arguments to the log-likelihood
arglist_eval <- lapply(arglist, eval, pars_and_data) ##lambda
## evaluate response variable and assign its value to 'x'
arglist_eval$x <- eval(response, pars_and_data) #x = y
## derivative of log-lik wrt PDF parameters
d1 <- eval(d0, arglist_eval) ## sub back to d0
## compute the deriv of log_lik with respect to its parameters
parnames <- setdiff(all.vars(RHS), names(data))
dlist <- list()
glist <- list()
for (p in parnames) {
dlist[[p]] <- eval(Deriv(arglist$lambda, p), pars_and_data)
glist[[p]] <- -sum(d1 * dlist[[p]])
}
return(unlist(glist))
## d(loglik_pois/d(lambda))* d(lambda)/d(b0)
}
return(list(fn = fn, gr = gr))
}
mkfun(form2)
-sum(x*log(lambda(b0=1, b1=2))-lambda(b0=1, b1=2)-lfactorial(x))
x = dd$y
-sum(x*log(lambda(b0=1, b1=2))-lambda(b0=1, b1=2)-lfactorial(x))
lambda <- function(b0,b1) {b0 + b1*dd$latitude^2}
x = dd$y
-sum(x*log(lambda(b0=1, b1=2))-lambda(b0=1, b1=2)-lfactorial(x))
-sum(x*log(lambda(b0=1, b1=2))-lambda(b0=1, b1=2)-lfactorial(x)) == ff2$fn(c(b0=1,b1=2))
-sum(dpois(dd$y, 1 + 2*dd$latitude^2, log=TRUE))
-sum(dpois(dd$y, 1 + dd$latitude^2, log=TRUE))
-sum(dpois(dd$y, 1*dd$latitude^2, log=TRUE))
?dpois
-sum(numDeriv::grad(temp, 1*dd$latitude^2)*dd$latitude^2)
temp = -sum(dpois(dd$y, 1*dd$latitude^2, log=TRUE))
-sum(numDeriv::grad(temp, 1*dd$latitude^2)*dd$latitude^2)
##----------
-sum(dpois(dd$y, 1*dd$latitude^2, log=TRUE)) == ff$fn(c(b0=1))
b0=1
lambda = b0*dd$latitude^2
pois <- function(lambda){x2*log(lambda)-lambda-lfactorial(x2)}
### d/d(lambda) * d lambda / d(b2)
-sum(numDeriv::grad(pois,lambda)*dd$latitude^2) ##-113.5597
b0=1
lambda = b0*dd$latitude^2
pois <- function(lambda){x*log(lambda)-lambda-lfactorial(x)}
### d/d(lambda) * d lambda / d(b2)
-sum(numDeriv::grad(pois,lambda)*dd$latitude^2) ##-113.5597
### d/d(lambda) * d lambda / d(b2)
-sum(numDeriv::grad(pois,lambda)*dd$latitude^2) == ff$gr(c(b0=1))
ff$gr(c(b0=1))
### d/d(lambda) * d lambda / d(b2)
-sum(numDeriv::grad(pois,lambda)*dd$latitude^2) == ff$gr(c(b0=1))[['b0']]
ff$gr(c(b0=1))[['b0']]
-sum(numDeriv::grad(pois,lambda)*dd$latitude^2)
### d/d(lambda) * d lambda / d(b2)
-sum(numDeriv::grad(pois,lambda)*dd$latitude^2) == ff$gr(c(b0=1))[['b0']]
b0=1
b1=2
lambda = b0 + b1*dd$latitude^2
pois <- function(lambda){x*log(lambda)-lambda-lfactorial(x)}
### d/d(lambda) * d lambda / d(b0)
-sum(numDeriv::grad(pois,lambda)*1)
### d/d(lambda) * d lambda / d(b0)
-sum(numDeriv::grad(pois,lambda)*1) == ff2$gr(c(b0=1,b1=2))[['b0']]
ff2$gr(c(b0=1,b1=2))[['b0']]
### d/d(lambda) * d lambda / d(b0)
-sum(numDeriv::grad(pois,lambda)*1)
### d/d(lambda) * d lambda / d(b1)
-sum(numDeriv::grad(pois,lambda)*lattitude^2) #-4.823218
### d/d(lambda) * d lambda / d(b1)
-sum(numDeriv::grad(pois,lambda)*latitude^2) #-4.823218
### d/d(lambda) * d lambda / d(b1)
-sum(numDeriv::grad(pois,lambda)*dd$latitude^2) #-4.823218
ff2$gr(c(b0=1,b1=2))[['b0']] #43.85188
ff2$gr(c(b0=1,b1=2))[['b1']] #43.85188
### d/d(lambda) * d lambda / d(b1)
-sum(numDeriv::grad(pois,lambda)*dd$latitude^2) == ff2$gr(c(b0=1,b1=2))[['b1']] #43.85188
?dnorm
library(bbmle)
l e
-sum(dnorm(dd$y, mean=1 + 2*dd$latitude^2, sd=1, log=TRUE))
log(1)
log(1)+2
-sum(dnorm(dd$y, mean=1 + 2*dd$latitude^2, sd=1, log=TRUE))
mean1=1 + 2*dd$latitude^2
sd=1
-sum(-log(2*pi)/2-log(sd) - (dd$y-mean1)^2/(2*sd^2))
## confirming dnorm loglik func
mean1=1 + 2*dd$latitude^2
sd=1
-sum(dnorm(dd$y, mean=1 + 2*dd$latitude^2, sd=1, log=TRUE)) == -sum(-log(2*pi)/2-log(sd) - (dd$y-mean1)^2/(2*sd^2))
pi
## confirming dnorm loglik func
mean1=1 + 2*dd$latitude^2
sd=1
-sum(dnorm(dd$y, mean=1 + 2*dd$latitude^2, sd=1, log=TRUE)) == -sum(-log(2*3.141593)/2-log(sd) - (dd$y-mean1)^2/(2*sd^2))
pi
expression(po)
expression(pi)
list(expression(pi))
4*(4*atan(1/5) - atan(1/239))
## confirming dnorm loglik func
mean1=1 + 2*dd$latitude^2
sd=1
-sum(dnorm(dd$y, mean=1 + 2*dd$latitude^2, sd=1, log=TRUE)) == -sum(-log(2*4*(4*atan(1/5) - atan(1/239)))/2-log(sd) - (dd$y-mean1)^2/(2*sd^2))
month.abb
month.abb[1]
month.abb[2]
loglik_list <- list(
dpois = list(expr=expression(x * log(lambda) - lambda - lfactorial(x)),
params=c("lambda")),
dnorm = list(expression(-log(2*4*(4*atan(1/5) - atan(1/239)))/2-log(sd) - (x-mean)^2/(2*sd^2)),
params=c("mean","sd"))
)
#### need to convert pi as a build-in constant??? what if pi is a parameter
### take care of maybe the e constant
## data frame lat, long
y ~ dpois(exp(log_lambda), ...,
parameters = list(log_lambda = ~ poly(lat, long, 2))
)
mkfun <- function(formula, data) {
if(missing(data)) {
stop(paste("missing data...")) # if no data
}
RHS <- formula[[3]] # dpois(lambda = (b0 * latitude^2))
response <- formula[[2]] #y
ddistn <- as.character(RHS[[1]]) ## dpois /// get the name of distribution variable
arglist <- as.list(RHS[-1]) ## $lambda = (b0 * latitude^2) ///delete function name
arglist1 <- c(
list(x = response),
arglist, ##
list(log = TRUE)
)
fn <- function(pars) { ## parameter
pars_and_data <- c(as.list(pars), data)
r <- with(
pars_and_data,
-sum(do.call(ddistn, arglist1))
)
return(r)
}
gr <- function(pars) {
pars_and_data <- c(as.list(pars), data)
if (!ddistn %in% names(loglik_list)) {
stop("I can't evaluate the derivative for ", sQuote(ddistn))
}
## eventually we need to calculate partial derivatives of the log-likelihood
## with respect to all of its parameters
LL <- loglik_list[[ddistn]]$expr
mnames <- loglik_list[[ddistn]]$params
## ???
## setdiff(all.vars(LL), "x")  ## response var should be the only non-parameter
d0 <- Deriv(LL, mnames)
## evaluate all of the arguments to the log-likelihood
arglist_eval <- lapply(arglist, eval, pars_and_data) ##lambda
## evaluate response variable and assign its value to 'x'
arglist_eval$x <- eval(response, pars_and_data) #x = y
## derivative of log-lik wrt PDF parameters
d1 <- eval(d0, arglist_eval) ## sub back to d0
## compute the deriv of log_lik with respect to its parameters
parnames <- setdiff(all.vars(RHS), names(data))
dlist <- list()
glist <- list()
for (p in parnames) {
dlist[[p]] <- eval(Deriv(arglist$lambda, p), pars_and_data)
glist[[p]] <- -sum(d1 * dlist[[p]])
}
return(unlist(glist))
## d(loglik_pois/d(lambda))* d(lambda)/d(b0)
}
return(list(fn = fn, gr = gr))
}
### Test 3 --------------
form4 <- y ~ dnorm(mean = b0 + b1 * latitude^2, sd = sd)
mkfun(form4, data=dd)
ff4 <- mkfun(form4, data=dd)
ff4$gr(c(b0=1, b1=2))
ff4$fn(c(b0=1, b1=2))
ff4$fn(c(b0=1, b1=2)) == -sum(dnorm(dd$y, mean=1 + 2*dd$latitude^2, sd=1, log=TRUE))
?atan
rm(list = ls())
library(devtools)
library(roxygen2)
search()
## HOW TO MAKE THIS REQUIRE PACKAGE
requireNamespace("Deriv", quietly = TRUE)
rm(list=ls())
search()
mle2()
## HOW TO MAKE THIS REQUIRE PACKAGE
requireNamespace("Deriv", quietly = TRUE)
search()
## HOW TO MAKE THIS REQUIRE PACKAGE
usethis::use_package("Deriv")
## HOW TO MAKE THIS REQUIRE PACKAGE
usethis::use_package("Deriv")
#' @export
mkfun <- function(formula, data) {
if(missing(data)) {
stop(paste("missing data...")) # if no data
}
RHS <- formula[[3]] # dpois(lambda = (b0 * latitude^2))
response <- formula[[2]] #y
ddistn <- as.character(RHS[[1]]) ## dpois /// get the name of distribution variable
arglist <- as.list(RHS[-1]) ## $lambda = (b0 * latitude^2) ///delete function name
arglist1 <- c(
list(x = response),
arglist, ##
list(log = TRUE)
)
fn <- function(pars) { ## parameter
pars_and_data <- c(as.list(pars), data)
r <- with(
pars_and_data,
-sum(do.call(ddistn, arglist1))
)
return(r)
}
gr <- function(pars) {
pars_and_data <- c(as.list(pars), data)
if (!ddistn %in% names(loglik_list)) {
stop("I can't evaluate the derivative for ", sQuote(ddistn))
}
## eventually we need to calculate partial derivatives of the log-likelihood
## with respect to all of its parameters
LL <- loglik_list[[ddistn]]$expr
mnames <- loglik_list[[ddistn]]$params
## ???
## setdiff(all.vars(LL), "x")  ## response var should be the only non-parameter
d0 <- Deriv::Deriv(LL, mnames)
## evaluate all of the arguments to the log-likelihood
arglist_eval <- lapply(arglist, eval, pars_and_data) ##lambda
## evaluate response variable and assign its value to 'x'
arglist_eval$x <- eval(response, pars_and_data) #x = y
## derivative of log-lik wrt PDF parameters
d1 <- eval(d0, arglist_eval) ## sub back to d0
## compute the deriv of log_lik with respect to its parameters
parnames <- setdiff(all.vars(RHS), names(data))
dlist <- list()
glist <- list()
for (p in parnames) {
dlist[[p]] <- eval(Deriv::Deriv(arglist$lambda, p), pars_and_data)
glist[[p]] <- -sum(d1 * dlist[[p]])
}
return(unlist(glist))
## d(loglik_pois/d(lambda))* d(lambda)/d(b0)
}
return(list(fn = fn, gr = gr))
}
library(devtools)
document()
rm(list = ls())
document()
# List of log-lik function for different ditributions
loglik_list <- list(
dpois = list(expr=expression(x * log(lambda) - lambda - lfactorial(x)),
params=c("lambda")),
dnorm = list(expr=expression(-log(2*4*(4*atan(1/5)-atan(1/239)))/2-log(sd) - (x-mean)^2/(2*sd^2)),
params=c("mean","sd"))
)
